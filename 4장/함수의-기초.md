## 함수

- 자바스크립트에서 함수는 **일련의 처리를 하나로 모아 언제든 호출할 수 있도록 만들어둔 것**
- 함수의 입력값을 인수라고 부르고, 출력 값은 반환값이라고 부른다.

## 함수 선언문으로 함수 정의하기

- 함수는 `function` 키워드를 사용하여 정의한다.
    
    ```jsx
    function square(x) { return x * x; }
    ```
    

## 함수 이름

- 변수 이름과 마찬가지로 모든 식별자를 함수 이름으로 사용할 수 있다.
- 함수 이름은 해당 함수의 기능을 이해하기 쉽게 지어야한다.
- 함수 이름은 일반적으로 동사 또는 동사로 시작되는 어휘로 만든다.
- 캐멀 표기법 또는 밑줄 표기법(스네이크)을 사용한다.

## 함수 호출

- 함수를 호출하려면 함수 이름 뒤에 소괄호로 인수를 묶어 입력한다.
    
    ```jsx
    square(3)
    ```
    
- **함수를 호출할 때 전달하는 값을 인수(argument)**, **함수 정의문의 인수를 인자(parameter)**라고 부른다.

## 인수

- 함수는 인수를 여러 개 받을 수 있다.
- 인수가 여러개라면 인수와 인수를 쉼표(`,`)로 구분한다.
- 인수를 받지 않는 함수도 정의할 수 있다.
    
    ```jsx
    var bark = function() { console.log('Bow-wow'); };
    bark();
    ```
    
    - `bark` 함수에는 인수도 없고 `return`문도 존재하지 않는다.
    - `return` 문이 실행되지 않는 상태에서 제어권이 함수를 호출한 코드로 되돌아가면 **함수의 반환값이 `undefined`가 된다.**
        
        ```jsx
        console.log(bark());   // undefined
        ```
        

## 함수의 실행 흐름

일반적인 실행 흐름은 다음과 같다.

1. 호출한 코드에 있는 인수가 함수 정의문의 인자에 대입된다.
2. 함수 정의문의 중괄호 안에 작성된 프로그램이 순차적으로 실행된다.
3. `return` 문이 실행되면 호출한 코드로 돌아간다.
    1. `return` 문의 값은 함수의 반환값이 된다.
4. `return` 문이 실행되지 않은 상태로 마지막 문장이 실행되면, 호출한 코드로 돌아간 후에 `undefined`가 함수의 반환값이 된다.

## 함수 선언문의 끌어올림

- 자바스크립트 엔진은 변수 선언문과 마찬가지로 **함수 선언문을 프로그램의 첫머리로 끌어올린다.**
- 함수 선언문은 프로그램의 어떤 위치에도 작성할 수 있다.

## 값으로서의 함수

- 자바스크립트에서는 **함수가 객체이다.**
- 함수 선언문으로 함수를 선언하면, **내부적으로는 그 함수 이름을 변수 이름으로 한 변수와 함수 객체**가 만들어지고, **그 변수에 함수 객체의 참조가 저장된다.**
    - 해당 변수 값을 다른 변수에 할당하면 그 변수 이름으로 함수를 실행할 수 있다.
        
        ```jsx
        var sq = square;
        console.log(sq(5));
        ```
        

## 참조에 의한 호출과 값에 의한 호출

- 함수는 원시 값을 인수로 넘겼을 때와 객체를 인수로 넘겼을 때 다르게 동작한다.

### 인수가 원시값일 경우

```jsx
function add1(x) {
	return x = x + 1;
}

var a = 3;
var b = add1(a);

console.log("a = " + a + ", b = " + b);   // a = 3, b = 4
```

- `add1`은 전달받은 인수에 1을 더하여 반환하는 함수이다.
- 함수가 호출될 때 **변수 a의 복사본이 인자 x에 할당**된다.
    - 즉, 인수에 원시 값을 넘기면 그 값 자체가 인자에 전달된다.
    - 이를 가리켜 값의 전달이라고 한다.
    - 이 때 변수 a와 변수 x는 **다른 영역의 메모리에 위치한 별개의 변수이기 때문에 x값을 바꾸더라도 a값은 바뀌지 않는다.**

### 인수가 객체인 경우

```jsx
function add1(p) {
	p.x = p.x + 1;
	p.y = p.y + 1;
	
	return p;
}

var a = { x: 3, y: 4 };
var b = add1(a);

console.log(a, b);   // Object {x=4, y=5} Object {x=4, y=5}
```

- `add1` 함수는 2차원 좌표의 각 성분에 1을 더한 좌표를 반환하는 함수이다.
- 함수가 호출될 때 변수 a의 복사본이 인자 p에 할당된다.
    - 그러나 변수 a에 객체 `{ x: 3, y: 4 }`의 참조가 저장되어 있으며, 이 참조 값을 인자 p에 대입한다.
    - 즉, **인수로 객체를 넘겼을 때 전달되는 값은 참조 값이다. → 참조 전달**
- 인자 p와 변수 a는 같은 객체를 참조하고 있기 때문에 수정 사항이 반영된다.

### 인수 여러 개를 우아하게 전달하는 방법(elegant way)

- 함수에 넘겨야하는 인수 개수가 많아지면 다음과 같은 문제점이 발생한다.
    - 인수의 순서를 착각하기 쉽다.
    - 함수가 받는 인수 개수를 바꾸면 함수의 호출 방법이 바뀌므로 프로그램 전체를 수정해야 한다.
- **객체의 프로퍼티에 인수를 담아서 넘기면 이러한 문제를 해결**할 수 있다. (DTO 개념)
    
    ```jsx
    function setBallProperties(x, y, vx, vy, radius) { ... }
    ...
    setBallProperties(0, 0, 10, 15, 5);
    ```
    
    - 위 함수의 인수를 다음과 같이 수정한다.
        
        ```jsx
        var parameters = {
        	x: 0,
        	y: 0,
        	vx: 10,
        	vy: 15,
        	radius: 5
        };
        
        function setBallProperties(params) { ... }
        ...
        setBallProperties(parameters);
        ```
        
        - 단, **함수 안에서 객체의 프로퍼티를 수정하면 호출한 코드에 있는 인수 객체의 프로퍼티가 함께 바뀌기 때문에 주의해야한다.**

## 변수의 유효범위

### 전역 유효 범위와 지역 유효 범위

- 변수에 접근할 수 있는 범위를 그 변수의 **유효 범위(scope)**라고 한다.
- 유효 범위를 결정하는 방법에는 두 가지가 있다.
    - **프로그램의 구문만으로 유효 범위를 정하는 어휘적 범위(lexical scope)**와 **프로그램 실행 중에 유효 범위를 정하는 동적 범위(dynamic scope)**가 있다.
    - C, Java와 같은 프로그래밍 언어와 마찬가지로 **자바스크립트도 어휘적 범위를 채택하고 있다.**
- 자바스크립트 변수는 변수의 유효 범위에 따라 전역 변수와 지역 변수 두 가지로 나뉜다.
    - 전역 변수는 **함수 바깥에서 선언된 변수로 유효 범위가 전체 프로그램**이다.
    - 지역 변수는 **함수 안에서 선언된 변수와 함수 인자**로 **유효 범위는 변수가 선언된 함수 내부이다.**

### 변수의 충돌

- 변수에 유효 범위가 있는 이유는 프로그램의 다른 부분에서 선언된 이름이 같은 변수와 충돌하지 않도록 하기 위해서이다.
- 다른 함수 내부에서 선언된 각각의 지역 변수는 모두 선언된 함수 내부에서만 유효하므로 이름이 같아도 충돌하지 않는다.
- 그러나 전역 변수 이름과 지역 변수 이름이 같아지면 두 변수가 충돌한다.
    
    ```jsx
    var a = "global";
    
    function f() {
    	var a = "local";
    	console.log(a);  // local
    	return a;
    }
    
    f();
    console.log(a)  // global
    ```
    
    - 이 때는 우선순위가 지역 변수가 더 높다.
    - 두 변수는 이름이 같지만 다른 위치의 메모리에 있는 별개의 변수이다.
    - **지역 변수 a의 유효 범위 안에서 전역 변수 a는 숨겨진다.**

### 함수 안에서의 변수 선언과 변수 끌어올림

```jsx
function f() {
	console.log(a);   // undefined
	var a = "local";
	console.log(a);   // local
	return a;
}
```

- **함수 안에서 선언된 지역 변수의 유효 범위는 함수의 전체**이다.
- 함수 중간 부분에서 변수를 선언하더라도 **변수는 함수 첫머리에서 선언된 것처럼 함수 안의 다른 문장보다 먼저 생성된다.**
    - 즉, 자바스크립트 엔진은 **함수 안의 변수 선언부를 함수의 첫머리로 끌어올린다.**

### 함수 안에서 변수 선언 생략

```jsx
function f() {
	a = "local";
	console.log(a);   // local
	return a;
}

f();
console.log(a);   // local
```

- **변수를 선언하지 않은 상태에서 값을 대입하면 전역 변수로 선언**된다.

## 블록 유효 범위: let과 const

- `let`과 `const`는 ECMAScript 6부터 추가된 변수 선언자로 모두가 **블록 유효 범위를 갖는 변수를 선언한다.**
- 블록 유효범위를 가진 변수는 중괄호(`{}`) 안에서만 유효하다.
- `let`은 변수를 선언하고, `const`는 한 번만 할당할 수 있는 상수를 선언한다.

### let

- 블록 유효 범위를 갖는 지역 변수를 선언한다.
- 또한, `let`문으로 똑같은 이름을 가진 변수를 선언하면 문법 오류가 발생한다.
    
    ```jsx
    let x;
    let x;    // Uncaught SyntaxError
    ```
    

### const

- 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언한다.
- `const`로 선언한 상수는 `let`으로 선언한 변수처럼 동작한다.
    - 단, 반드시 초기화해야한다는 차이점이 있다.
- `const` 문으로 선언한 변수에 다시 대입을 시도하면 타입 오류가 발생한다.
    
    ```jsx
    const c = 2;
    c = 5;  // TypeError
    ```
    
- const로 선언한 상수는 수정할 수 없지만, 상수 값이 객체이거나 배열일 경우에는 프로퍼티 값을 수정할 수 있다.
    
    ```jsx
    const origin = { x: 1, y: 2 };
    origin.x = 3;
    console.log(origin);   // Object {x:3, y:2}
    ```
    

## 함수 리터럴로 함수 정의하기

- 함수는 함수 리터럴로도 정의할 수 있다.
    
    ```jsx
    var square = function(x) { return x * x; };
    ```
    
    - `function(x) { … }` 부분이 함수 리터럴이다.
- 함수 리터럴은 이름이 없는 함수이므로 **익명 함수 또는 무명 함수**라고 부른다.
- 함수 선언문에서는 끝에 세미콜론을 붙일 필요가 없지만, **함수 리터럴을 사용할 땐 반드시 세미콜론을 붙여야 한다.**
- 함수 선언문으로 정의한 함수와 함수 리터럴로 정의한 함수의 사용법은 같다.
    - 이는 함수 리터럴과 함수 선언문이 **모두 내부적으로 square 변수에 함수 객체의 참조를 저장하기 때문이다.**
    - 차이점이 있다면 **자바스크립트 엔진이 함수 선언문으로 정의한 함수는 끌어올리지만, 함수 리터럴로 정의한 함수는 끌어올리지 않는다.**
        - 함수 리터럴로 정의한 익명 함수는 변수에 할당한 후에야 비로소 square라는 이름을 갖게 되고, 그 이름으로 호출할 수 있게 된다.
        - 이러한 이유 때문에 함수를 정의하지 않은 상태에서 함수를 사용하려고 하면 타입 오류가 발생한다.
            
            ```jsx
            console.log(square(3));   // TypeError: square is not a function
            var square = function(x) { return x * x; };
            ```
            
- 익명 함수에도 이름을 붙일 수 있다.
    
    ```jsx
    var square = function sq(x) { return x * x; };
    ```
    
    - 그러나 sq라는 이름은 함수 안에서만 유효하기 때문에 함수 바깥에서는 sq라는 이름으로 함수를 호출할 수 없다.
    - 익명 함수 코드는 디버거에 모두 `anonymous function`이라고 표시되기 때문에 함수를 구별할 수 없다는 단점이 있는데, 이 때 이름을 붙인 익명 함수는 어떤 함수인지 확인할 수 있다.
    

## 객체의 메서드

- 객체의 프로퍼티 중에서 **함수 객체의 참조를 값으로 담고 있는 프로퍼티를 가리켜 메서드**라고 부른다.
- 메서드를 정의할 때는 프로퍼티 값으로 함수 리터럴을 대입한다.